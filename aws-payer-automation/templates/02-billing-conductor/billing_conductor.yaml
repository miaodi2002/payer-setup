AWSTemplateFormatVersion: '2010-09-09'
Description: "Create AWS Account and BillingConductor BillingGroup automatically"

Resources:
  # Lambdaæ‰§è¡Œè§’è‰²
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: LambdaBillingConductorRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: OrganizationsAndBillingAccess
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - organizations:DescribeOrganization
                  - organizations:DescribeAccount
                  - organizations:CreateAccount
                  - organizations:DescribeCreateAccountStatus
                  - organizations:ListAccounts
                  - billingconductor:CreateBillingGroup
                  - billingconductor:CreatePricingPlan
                  - billingconductor:AssociatePricingRules
                  - billingconductor:ListBillingGroups
                  - billingconductor:ListPricingPlans
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"

  # Lambdaå‡½æ•°
  CreateAccountAndBillingGroupFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: CreateAccountAndBillingGroup
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 1200  # 20åˆ†é’Ÿï¼ŒåŒ…æ‹¬è´¦æˆ·åˆ›å»ºæ—¶é—´(æœ€å¤š15åˆ†é’Ÿ) + CB familyé›†æˆç­‰å¾…æ—¶é—´(3åˆ†é’Ÿ) + å…¶ä»–æ“ä½œç¼“å†²æ—¶é—´
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          import time
          import re

          def lambda_handler(event, context):
              try:
                  if event['RequestType'] == 'Delete':
                      # åˆ é™¤æ—¶ä¸åšä»»ä½•æ“ä½œï¼Œé¿å…åˆ é™¤å·²åˆ›å»ºçš„è´¦æˆ·
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return

                  organizations = boto3.client('organizations')
                  billingconductor = boto3.client('billingconductor')

                  # 1. è·å–Management Accountä¿¡æ¯
                  org_info = organizations.describe_organization()
                  master_account_id = org_info['Organization']['MasterAccountId']
                  
                  master_account_info = organizations.describe_account(AccountId=master_account_id)
                  master_account_name = master_account_info['Account']['Name']
                  master_account_email = master_account_info['Account']['Email']

                  print(f"Master Account: {master_account_name} ({master_account_email})")

                  # 2. æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨Billsè´¦æˆ·
                  new_account_name = f"{master_account_name}-Bills"
                  base_email = generate_bills_email(master_account_email)
                  
                  # 3. æŸ¥æ‰¾ç°æœ‰çš„Billsè´¦æˆ·
                  existing_account = find_existing_bills_account(organizations, master_account_name, master_account_email)
                  
                  if existing_account:
                      new_account_id = existing_account['Id']
                      new_account_email = existing_account['Email']
                      print(f"Found existing Bills account: {existing_account['Name']} ({new_account_email}) - ID: {new_account_id}")
                  else:
                      # 4. å¦‚æœä¸å­˜åœ¨ï¼ŒæŸ¥æ‰¾å¯ç”¨é‚®ç®±å¹¶åˆ›å»ºæ–°è´¦æˆ·
                      new_account_email = find_available_email(organizations, base_email)
                      
                      print(f"No existing Bills account found. Creating new account: {new_account_name} ({new_account_email})")

                      # 5. åˆ›å»ºæ–°è´¦æˆ·
                      create_response = organizations.create_account(
                          Email=new_account_email,
                          AccountName=new_account_name
                      )
                      
                      request_id = create_response['CreateAccountStatus']['Id']
                      print(f"Account creation request ID: {request_id}")

                      # 6. ç­‰å¾…è´¦æˆ·åˆ›å»ºå®Œæˆ
                      new_account_id = wait_for_account_creation(organizations, request_id)
                      print(f"New account created: {new_account_id}")
                      
                      # 7. ç­‰å¾…3åˆ†é’Ÿè®©è´¦æˆ·åŠ å…¥Consolidated Billing family
                      print("Waiting 3 minutes for the account to join the CB family...")
                      wait_for_cb_family_integration(180)  # 3åˆ†é’Ÿ = 180ç§’
                      print("Wait completed. Account should now be available for BillingConductor operations.")

                  # 8. åˆ›å»ºæˆ–æŸ¥æ‰¾BillingGroup
                  billing_group_arn = create_or_find_billing_group(billingconductor, new_account_id)
                  print(f"BillingGroup ready: {billing_group_arn}")
                  
                  # 9. è·å–æœ€ç»ˆçš„BillingGroupä¿¡æ¯ç”¨äºå“åº”
                  try:
                      final_group_info = billingconductor.get_billing_group(Arn=billing_group_arn)
                      final_group_name = final_group_info.get('Name', 'Unknown')
                      print(f"ğŸ“‹ Final BillingGroup Summary:")
                      print(f"   Name: {final_group_name}")
                      print(f"   ARN: {billing_group_arn}")
                      print(f"   Primary Account: {new_account_id}")
                      
                      # è®°å½•åç§°ä¸åŒ¹é…çš„æƒ…å†µï¼ˆè¿™æ˜¯AWSçš„æ­£å¸¸è¡Œä¸ºï¼‰
                      if final_group_name.lower() != 'bills':
                          print(f"â„¹ï¸  AWS assigned name '{final_group_name}' (expected AWS behavior)")
                      
                      success_message = f"Account and BillingGroup created successfully. BillingGroup name: {final_group_name}"
                      
                  except Exception as info_error:
                      print(f"âš ï¸  Could not retrieve final BillingGroup info: {str(info_error)}")
                      success_message = "Account and BillingGroup created successfully"

                  response_data = {
                      "NewAccountId": new_account_id,
                      "NewAccountEmail": new_account_email,
                      "BillingGroupArn": billing_group_arn,
                      "Message": success_message
                  }

                  cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)

              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {"Error": str(e)})

          def generate_bills_email(original_email):
              """ç”Ÿæˆ+billsé‚®ç®±alias"""
              if '+' in original_email:
                  # å¦‚æœå·²ç»æœ‰aliasï¼Œåœ¨@å‰æ·»åŠ bills
                  local, domain = original_email.split('@')
                  return f"{local}bills@{domain}"
              else:
                  # æ²¡æœ‰aliasï¼Œæ·»åŠ +bills
                  local, domain = original_email.split('@')
                  return f"{local}+bills@{domain}"

          def find_existing_bills_account(organizations, master_account_name, master_account_email):
              """æŸ¥æ‰¾ç°æœ‰çš„Billsè´¦æˆ·"""
              try:
                  accounts = organizations.list_accounts()['Accounts']
                  
                  # ç”Ÿæˆå¯èƒ½çš„Billsè´¦æˆ·åç§°æ¨¡å¼
                  possible_names = [
                      f"{master_account_name}-Bills",
                      f"{master_account_name}Bills",
                      f"Bills-{master_account_name}",
                      f"Bills{master_account_name}"
                  ]
                  
                  # ç”Ÿæˆå¯èƒ½çš„é‚®ç®±æ¨¡å¼
                  local_part, domain = master_account_email.split('@')
                  possible_emails = []
                  
                  # åŸºç¡€+billsæ¨¡å¼
                  possible_emails.append(f"{local_part}+bills@{domain}")
                  
                  # å¸¦æ•°å­—åç¼€çš„æ¨¡å¼
                  for i in range(1, 10):  # æ£€æŸ¥1-9çš„åç¼€
                      possible_emails.append(f"{local_part}+bills{i}@{domain}")
                      possible_emails.append(f"{local_part}bills{i}@{domain}")
                  
                  # ä¸å¸¦+çš„æ¨¡å¼
                  possible_emails.append(f"{local_part}bills@{domain}")
                  
                  print(f"Searching for existing Bills accounts with names: {possible_names}")
                  print(f"Searching for existing Bills accounts with emails: {possible_emails[:5]}... (and more variations)")
                  
                  for account in accounts:
                      account_name = account.get('Name', '')
                      account_email = account.get('Email', '').lower()
                      account_status = account.get('Status', '')
                      
                      # è·³è¿‡ç®¡ç†è´¦æˆ·
                      if account.get('Id') == account.get('MasterAccountId', ''):
                          continue
                      
                      # è·³è¿‡éæ´»è·ƒè´¦æˆ·
                      if account_status != 'ACTIVE':
                          print(f"Skipping account {account_name} - Status: {account_status}")
                          continue
                      
                      # æ£€æŸ¥è´¦æˆ·åç§°æ˜¯å¦åŒ¹é…
                      name_match = any(possible_name.lower() in account_name.lower() or 
                                     account_name.lower() in possible_name.lower() 
                                     for possible_name in possible_names)
                      
                      # æ£€æŸ¥é‚®ç®±æ˜¯å¦åŒ¹é…
                      email_match = any(possible_email.lower() == account_email 
                                      for possible_email in possible_emails)
                      
                      # æ£€æŸ¥æ˜¯å¦åŒ…å«billså…³é”®è¯
                      bills_in_name = 'bills' in account_name.lower()
                      bills_in_email = 'bills' in account_email
                      
                      if name_match or email_match or (bills_in_name and bills_in_email):
                          print(f"Found potential Bills account: {account_name} ({account['Email']}) - ID: {account['Id']}")
                          
                          # è¿›ä¸€æ­¥éªŒè¯ï¼šç¡®ä¿ä¸æ˜¯å…¶ä»–ç”¨é€”çš„è´¦æˆ·
                          if ('bills' in account_name.lower() or 'bills' in account_email) and account_status == 'ACTIVE':
                              print(f"Confirmed Bills account: {account_name}")
                              return account
                  
                  print("No existing Bills account found")
                  return None
                  
              except Exception as e:
                  print(f"Error searching for existing Bills account: {str(e)}")
                  return None

          def find_available_email(organizations, base_email):
              """æŸ¥æ‰¾å¯ç”¨çš„é‚®ç®±åœ°å€"""
              # è·å–æ‰€æœ‰ç°æœ‰è´¦æˆ·
              accounts = organizations.list_accounts()['Accounts']
              existing_emails = {acc['Email'].lower() for acc in accounts}
              
              # æ£€æŸ¥åŸºç¡€é‚®ç®±æ˜¯å¦å¯ç”¨
              if base_email.lower() not in existing_emails:
                  return base_email
              
              # å¦‚æœä¸å¯ç”¨ï¼Œæ·»åŠ æ•°å­—åç¼€
              local, domain = base_email.split('@')
              if '+bills' in local:
                  base_local = local  # service+bills
              else:
                  base_local = local.replace('bills', '+bills')  # servicebills -> service+bills
              
              for i in range(1, 100):  # æœ€å¤šå°è¯•99æ¬¡
                  test_email = f"{base_local}{i}@{domain}"
                  if test_email.lower() not in existing_emails:
                      return test_email
              
              raise Exception("Cannot find available email after 99 attempts")

          def wait_for_account_creation(organizations, request_id):
              """ç­‰å¾…è´¦æˆ·åˆ›å»ºå®Œæˆ"""
              max_attempts = 60  # æœ€å¤šç­‰å¾…30åˆ†é’Ÿ (60 * 30ç§’)
              
              for attempt in range(max_attempts):
                  time.sleep(30)  # ç­‰å¾…30ç§’
                  
                  status = organizations.describe_create_account_status(
                      CreateAccountRequestId=request_id
                  )
                  
                  state = status['CreateAccountStatus']['State']
                  print(f"Account creation attempt {attempt + 1}: {state}")
                  
                  if state == 'SUCCEEDED':
                      return status['CreateAccountStatus']['AccountId']
                  elif state == 'FAILED':
                      failure_reason = status['CreateAccountStatus'].get('FailureReason', 'Unknown')
                      raise Exception(f"Account creation failed: {failure_reason}")
              
              raise Exception("Account creation timeout after 30 minutes")

          def wait_for_cb_family_integration(wait_seconds):
              """ç­‰å¾…è´¦æˆ·åŠ å…¥Consolidated Billing family"""
              print(f"Starting CB family integration wait: {wait_seconds} seconds")
              
              # å°†ç­‰å¾…æ—¶é—´åˆ†æˆ12ä¸ª5ç§’é—´éš”ï¼Œæ¯15ç§’æ‰“å°ä¸€æ¬¡çŠ¶æ€
              intervals = wait_seconds // 15  # æ¯15ç§’ä¸€ä¸ªé—´éš”
              remaining_wait = wait_seconds % 15
              
              for i in range(intervals):
                  elapsed = i * 15
                  remaining = wait_seconds - elapsed
                  print(f"CB family integration wait: {elapsed}s elapsed, {remaining}s remaining...")
                  time.sleep(15)
              
              # å¤„ç†å‰©ä½™çš„ç­‰å¾…æ—¶é—´
              if remaining_wait > 0:
                  elapsed = intervals * 15
                  print(f"CB family integration wait: {elapsed}s elapsed, {remaining_wait}s remaining...")
                  time.sleep(remaining_wait)
              
              print(f"CB family integration wait completed: {wait_seconds} seconds total")

          def create_or_find_billing_group(billingconductor, primary_account_id):
              """æŸ¥æ‰¾ç°æœ‰BillingGroupæˆ–åˆ›å»ºæ–°çš„ï¼Œç¡®ä¿æ–°åˆ›å»ºçš„ä½¿ç”¨'Bills'åç§°"""
              try:
                  # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨BillingGroups
                  print(f"Checking for existing BillingGroups for account {primary_account_id}")
                  
                  existing_groups = billingconductor.list_billing_groups()
                  
                  for group in existing_groups.get('BillingGroups', []):
                      group_name = group.get('Name', '')
                      group_primary_account = group.get('PrimaryAccountId', '')
                      group_arn = group.get('Arn', '')
                      
                      print(f"Found BillingGroup: {group_name} (Primary: {group_primary_account})")
                      
                      # å¦‚æœæ‰¾åˆ°ç›¸åŒPrimary Accountçš„BillingGroupï¼Œç›´æ¥ä½¿ç”¨
                      if group_primary_account == primary_account_id:
                          print(f"âœ… Found existing BillingGroup for this account: {group_name}")
                          print(f"â„¹ï¸  Using existing BillingGroup: {group_arn}")
                          return group_arn
                  
                  # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç°æœ‰çš„BillingGroupï¼Œåˆ›å»ºæ–°çš„
                  print(f"ğŸ¯ No existing BillingGroup found for account {primary_account_id}")
                  print(f"ğŸ¯ Creating new BillingGroup with name 'Bills'")
                  return create_billing_group(billingconductor, primary_account_id)
                  
              except Exception as e:
                  print(f"Error in create_or_find_billing_group: {str(e)}")
                  # å¦‚æœåˆ—è¡¨æ“ä½œå¤±è´¥ï¼Œå°è¯•ç›´æ¥åˆ›å»º
                  print("Falling back to direct creation")
                  return create_billing_group(billingconductor, primary_account_id)

          def create_billing_group(billingconductor, primary_account_id):
              """åˆ›å»ºBillingGroup"""
              try:
                  # è·å–å½“å‰è´¦æˆ·IDç”¨äºæ„å»ºé»˜è®¤ARN
                  import boto3
                  sts = boto3.client('sts')
                  account_id = sts.get_caller_identity()['Account']
                  print(f"Current account ID: {account_id}")
                  
                  # é¦–å…ˆå°è¯•åˆ—å‡ºå¯ç”¨çš„ pricing plans
                  try:
                      pricing_plans = billingconductor.list_pricing_plans()
                      print(f"Available pricing plans: {pricing_plans}")
                      
                      # æŸ¥æ‰¾å¯ç”¨çš„å®šä»·è®¡åˆ’
                      standard_plan_arn = None
                      for plan in pricing_plans.get('PricingPlans', []):
                          plan_name = plan.get('Name', '')
                          plan_arn = plan.get('Arn', '')
                          print(f"Found pricing plan: {plan_name} - {plan_arn}")
                          
                          if 'standard' in plan_name.lower() or 'aws' in plan_name.lower() or 'default' in plan_name.lower():
                              standard_plan_arn = plan_arn
                              print(f"Selected pricing plan: {standard_plan_arn}")
                              break
                      
                      # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ ‡å‡†è®¡åˆ’ï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨çš„è®¡åˆ’
                      if not standard_plan_arn and pricing_plans.get('PricingPlans'):
                          standard_plan_arn = pricing_plans['PricingPlans'][0].get('Arn')
                          print(f"Using first available pricing plan: {standard_plan_arn}")
                      
                  except Exception as list_error:
                      print(f"Error listing pricing plans: {str(list_error)}")
                      standard_plan_arn = None
                  
                  # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•å®šä»·è®¡åˆ’ï¼Œå°è¯•åˆ›å»ºä¸€ä¸ªé»˜è®¤çš„
                  if not standard_plan_arn:
                      print("No existing pricing plans found, attempting to create default pricing plan")
                      try:
                          # åˆ›å»ºé»˜è®¤çš„å®šä»·è®¡åˆ’
                          pricing_plan_response = billingconductor.create_pricing_plan(
                              Name='DefaultPricingPlan',
                              Description='Default pricing plan for standard AWS pricing'
                          )
                          standard_plan_arn = pricing_plan_response['Arn']
                          print(f"Created default pricing plan: {standard_plan_arn}")
                      except Exception as create_plan_error:
                          print(f"Failed to create default pricing plan: {str(create_plan_error)}")
                          # æœ€åçš„å¤‡é€‰æ–¹æ¡ˆï¼šä½¿ç”¨ä¼°è®¡çš„ARNæ ¼å¼
                          import random
                          import string
                          random_id = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
                          standard_plan_arn = f"arn:aws:billingconductor::{account_id}:pricingplan/{random_id}"
                          print(f"Using fallback ARN: {standard_plan_arn}")
                  
                  # åˆ›å»º BillingGroupï¼Œå¼ºåˆ¶ä½¿ç”¨'Bills'åç§°
                  billing_group_name = 'Bills'
                  print(f"ğŸ¯ Creating BillingGroup with name '{billing_group_name}' and pricing plan: {standard_plan_arn}")
                  
                  create_params = {
                      'Name': billing_group_name,
                      'Description': f'Billing group for customer original pricing - Account {primary_account_id}',
                      'PrimaryAccountId': primary_account_id,
                      'AccountGrouping': {
                          'LinkedAccountIds': [primary_account_id]
                      },
                      'ComputationPreference': {
                          'PricingPlanArn': standard_plan_arn
                      }
                  }
                  
                  print(f"ğŸ“‹ Create parameters: Name='{create_params['Name']}'")
                  response = billingconductor.create_billing_group(**create_params)
                  
                  created_arn = response['Arn']
                  print(f"âœ… BillingGroup created successfully: {created_arn}")
                  
                  # éªŒè¯åˆ›å»ºçš„BillingGroupåç§°
                  try:
                      group_info = billingconductor.get_billing_group(Arn=created_arn)
                      actual_name = group_info.get('Name', 'Unknown')
                      print(f"ğŸ“‹ BillingGroup verification:")
                      print(f"   Requested name: '{billing_group_name}'")
                      print(f"   Actual name: '{actual_name}'")
                      print(f"   ARN: {created_arn}")
                      
                      if actual_name.lower() == billing_group_name.lower():
                          print(f"âœ… SUCCESS: BillingGroup name is correctly set to '{actual_name}'")
                      else:
                          print(f"âŒ ERROR: AWS assigned name '{actual_name}' instead of requested '{billing_group_name}'")
                          # å¦‚æœåç§°ä¸åŒ¹é…ï¼Œè¿™å¯èƒ½æ˜¯ä¸€ä¸ªä¸¥é‡çš„é—®é¢˜
                          raise Exception(f"BillingGroup name mismatch: expected '{billing_group_name}', got '{actual_name}'")
                      
                  except Exception as verify_error:
                      print(f"âš ï¸  Could not verify BillingGroup name: {str(verify_error)}")
                      raise verify_error
                  
                  return created_arn
                  
              except Exception as e:
                  print(f"BillingGroup creation error: {str(e)}")
                  # å¦‚æœè¿˜æ˜¯å¤±è´¥ï¼Œå°è¯•æœ€ç®€å•çš„åˆ›å»ºæ–¹å¼
                  try:
                      billing_group_name = 'Bills'
                      print(f"ğŸ¯ Attempting simple BillingGroup creation with name '{billing_group_name}'")
                      response = billingconductor.create_billing_group(
                          Name=billing_group_name,
                          Description=f'Billing group for customer original pricing - Account {primary_account_id}',
                          PrimaryAccountId=primary_account_id,
                          AccountGrouping={
                              'LinkedAccountIds': [primary_account_id]
                          },
                          ComputationPreference={}  # ç©ºçš„ ComputationPreference
                      )
                      
                      fallback_arn = response['Arn']
                      print(f"âœ… Fallback BillingGroup created: {fallback_arn}")
                      
                      # éªŒè¯fallbackåˆ›å»ºçš„åç§°
                      try:
                          group_info = billingconductor.get_billing_group(Arn=fallback_arn)
                          actual_name = group_info.get('Name', 'Unknown')
                          print(f"ğŸ“‹ Fallback BillingGroup verification:")
                          print(f"   Requested name: '{billing_group_name}'")
                          print(f"   Actual name: '{actual_name}'")
                          
                          if actual_name.lower() == billing_group_name.lower():
                              print(f"âœ… SUCCESS: Fallback BillingGroup name correctly set to '{actual_name}'")
                          else:
                              print(f"âš ï¸  Fallback BillingGroup got name '{actual_name}' instead of '{billing_group_name}'")
                              
                      except Exception as verify_error:
                          print(f"âš ï¸  Could not verify fallback BillingGroup name: {str(verify_error)}")
                      
                      return fallback_arn
                  except Exception as simple_error:
                      print(f"Simple creation also failed: {str(simple_error)}")
                      raise e

  # Custom Resourceè§¦å‘Lambda
  CreateAccountAndBillingGroup:
    Type: Custom::CreateAccountAndBillingGroup
    Properties:
      ServiceToken: !GetAtt CreateAccountAndBillingGroupFunction.Arn

Outputs:
  NewAccountId:
    Description: "ID of the newly created account"
    Value: !GetAtt CreateAccountAndBillingGroup.NewAccountId
    Export:
      Name: !Sub "${AWS::StackName}-NewAccountId"

  NewAccountEmail:
    Description: "Email of the newly created account"
    Value: !GetAtt CreateAccountAndBillingGroup.NewAccountEmail
    Export:
      Name: !Sub "${AWS::StackName}-NewAccountEmail"

  BillingGroupArn:
    Description: "ARN of the created BillingGroup"
    Value: !GetAtt CreateAccountAndBillingGroup.BillingGroupArn
    Export:
      Name: !Sub "${AWS::StackName}-BillingGroupArn"