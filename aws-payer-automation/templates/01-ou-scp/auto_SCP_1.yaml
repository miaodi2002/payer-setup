AWSTemplateFormatVersion: '2010-09-09'
Description: "Create OU and attach SCP to Root, Free, Normal OU"

Parameters:
  RootId:
    Type: String
    Description: "AWS Organizations root ID"

Resources:
  # 建立 Free OU
  FreeOU:
    Type: AWS::Organizations::OrganizationalUnit
    Properties:
      Name: "Free"
      ParentId: !Ref RootId

  # 建立 Block OU
  BlockOU:
    Type: AWS::Organizations::OrganizationalUnit
    Properties:
      Name: "Block"
      ParentId: !Ref RootId

  # 建立 Normal OU
  NormalOU:
    Type: AWS::Organizations::OrganizationalUnit
    Properties:
      Name: "Normal"
      ParentId: !Ref RootId

  DenyAccessNonPayAsGoDenyBigSizeACM:
    Type: "AWS::Organizations::Policy"
    Properties:
      Name: "DenyAccessNonPayAsGo_DenyBigSize_ACM"
      Description: "SCP to deny reserved instances, large EC2 instances, and ACM CA operations."
      Type: "SERVICE_CONTROL_POLICY"
      Content:
        Version: "2012-10-17"
        Statement:
          - Sid: "DenyAccessNonPayAsGo"
            Effect: "Deny"
            Action:
              - "ec2:PurchaseReservedInstancesOffering"
              - "ec2:AcceptReservedInstancesExchangeQuote"
              - "ec2:CancelCapacityReservation"
              - "ec2:CancelReservedInstancesListing"
              - "ec2:CreateCapacityReservation"
              - "ec2:CreateReservedInstancesListing"
              - "savingsplans:*"
              - "ec2:DescribeReservedInstances"
              - "ec2:DescribeReservedInstancesListings"
              - "ec2:ModifyReservedInstances"
              - "rds:PurchaseReservedDBInstancesOffering"
              - "elasticache:PurchaseReservedCacheNodesOffering"
              - "directconnect:*"
              - "outposts:*"
            Resource: "*"

          - Sid: "limitedSize"
            Effect: "Deny"
            Action: "ec2:RunInstances"
            Resource: "arn:aws:ec2:*:*:instance/*"
            Condition:
              ForAnyValue:StringNotLike:
                "ec2:InstanceType":
                  - "*.nano"
                  - "*.small"
                  - "*.micro"
                  - "*.medium"
                  - "*.large"
                  - "*.xlarge"
                  - "*.2xlarge"
                  - "*.3xlarge"
                  - "*.4xlarge"
                  - "*.6xlarge"
                  - "*.8xlarge"
                  - "*.9xlarge"
                  - "*.10xlarge"
                  - "*.12xlarge"
                  - "*.16xlarge"

          - Sid: "DenyACM"
            Effect: "Deny"
            Action:
              - "acm-pca:CreateCertificateAuthority"
              - "acm-pca:DeleteCertificateAuthority"
              - "acm-pca:CreatePermission"
              - "acm-pca:DeletePermission"
              - "acm-pca:DescribeCertificateAuthorityAuditReport"
              - "acm-pca:RestoreCertificateAuthority"
              - "acm-pca:TagCertificateAuthority"
              - "acm-pca:UntagCertificateAuthority"
            Resource: "*"

  DenyLeaveOrganization:
    Type: "AWS::Organizations::Policy"
    Properties:
      Name: "DenyLeaveOrganization"
      Description: "SCP to prevent accounts from leaving the AWS Organization."
      Type: "SERVICE_CONTROL_POLICY"
      Content:
        Version: "2012-10-17"
        Statement:
          - Sid: "Statement1"
            Effect: "Deny"
            Action:
              - "organizations:LeaveOrganization"
            Resource: "*"

  DenyRoot:
    Type: "AWS::Organizations::Policy"
    Properties:
      Name: "DenyRoot"
      Description: "SCP to deny all actions for the root user."
      Type: "SERVICE_CONTROL_POLICY"
      Content:
        Version: "2012-10-17"
        Statement:
          - Sid: "DenyRootUser"
            Effect: "Deny"
            Action: "*"
            Resource: "*"
            Condition:
              StringLike:
                aws:PrincipalArn: "arn:aws:iam::*:root"  
        
  DenyRootChange:
    Type: "AWS::Organizations::Policy"
    Properties:
      Name: "DenyRootChange"
      Description: "SCP to deny account email address change."
      Type: "SERVICE_CONTROL_POLICY"
      Content:
        Version: "2012-10-17"
        Statement:
          - Sid: "VisualEditor0"
            Effect: "Deny"
            Action: "iam:UpdateAccountEmailAddress"
            Resource: "*"

  DenySupport:
    Type: "AWS::Organizations::Policy"
    Properties:
      Name: "DenySupport"
      Description: "SCP to deny support plan changes."
      Type: "SERVICE_CONTROL_POLICY"
      Content:
        Version: "2012-10-17"
        Statement:
          - Effect: "Deny"
            Action: "supportplans:*"
            Resource: "*"

  DenyShield:
    Type: "AWS::Organizations::Policy"
    Properties:
      Name: "DenyShield"
      Description: "SCP to deny Shield subscription updates."
      Type: "SERVICE_CONTROL_POLICY"
      Content:
        Version: "2012-10-17"
        Statement:
          - Sid: "Statement1"
            Effect: "Deny"
            Action:
              - "shield:UpdateSubscription"
            Resource: "*"

  DenyCloudFront:
    Type: "AWS::Organizations::Policy"
    Properties:
      Name: "Deny_CloudFront"
      Description: "Service Control Policy to deny all CloudFront actions for specified IAM users."
      Type: "SERVICE_CONTROL_POLICY"
      Content: 
        Version: "2012-10-17"
        Statement:
          - Effect: "Deny"
            Action:
              - "cloudfront:*"
            Resource: "*"
            Condition:
              StringLike:
                aws:PrincipalArn:
                  - "arn:aws:iam::*:root"
                  - "arn:aws:iam::*:user/a*"
                  - "arn:aws:iam::*:user/A*"
                  - "arn:aws:iam::*:user/b*"
                  - "arn:aws:iam::*:user/B*"
                  - "arn:aws:iam::*:user/c*"
                  - "arn:aws:iam::*:user/C*"
                  - "arn:aws:iam::*:user/d*"
                  - "arn:aws:iam::*:user/D*"
                  - "arn:aws:iam::*:user/e*"
                  - "arn:aws:iam::*:user/E*"
                  - "arn:aws:iam::*:user/f*"
                  - "arn:aws:iam::*:user/F*"
                  - "arn:aws:iam::*:user/g*"
                  - "arn:aws:iam::*:user/G*"
                  - "arn:aws:iam::*:user/h*"
                  - "arn:aws:iam::*:user/H*"
                  - "arn:aws:iam::*:user/i*"
                  - "arn:aws:iam::*:user/I*"
                  - "arn:aws:iam::*:user/j*"
                  - "arn:aws:iam::*:user/J*"
                  - "arn:aws:iam::*:user/k*"
                  - "arn:aws:iam::*:user/K*"
                  - "arn:aws:iam::*:user/l*"
                  - "arn:aws:iam::*:user/L*"
                  - "arn:aws:iam::*:user/m*"
                  - "arn:aws:iam::*:user/M*"
                  - "arn:aws:iam::*:user/n*"
                  - "arn:aws:iam::*:user/N*"
                  - "arn:aws:iam::*:user/o*"
                  - "arn:aws:iam::*:user/O*"
                  - "arn:aws:iam::*:user/p*"
                  - "arn:aws:iam::*:user/P*"
                  - "arn:aws:iam::*:user/q*"
                  - "arn:aws:iam::*:user/Q*"
                  - "arn:aws:iam::*:user/r*"
                  - "arn:aws:iam::*:user/R*"
                  - "arn:aws:iam::*:user/s*"
                  - "arn:aws:iam::*:user/S*"
                  - "arn:aws:iam::*:user/t*"
                  - "arn:aws:iam::*:user/T*"
                  - "arn:aws:iam::*:user/u*"
                  - "arn:aws:iam::*:user/U*"
                  - "arn:aws:iam::*:user/v*"
                  - "arn:aws:iam::*:user/V*"
                  - "arn:aws:iam::*:user/w*"
                  - "arn:aws:iam::*:user/W*"
                  - "arn:aws:iam::*:user/x*"
                  - "arn:aws:iam::*:user/X*"
                  - "arn:aws:iam::*:user/y*"
                  - "arn:aws:iam::*:user/Y*"
                  - "arn:aws:iam::*:user/z*"
                  - "arn:aws:iam::*:user/Z*"
                  - "arn:aws:iam::*:user/0*"
                  - "arn:aws:iam::*:user/1*"
                  - "arn:aws:iam::*:user/2*"
                  - "arn:aws:iam::*:user/3*"
                  - "arn:aws:iam::*:user/4*"
                  - "arn:aws:iam::*:user/5*"
                  - "arn:aws:iam::*:user/6*"
                  - "arn:aws:iam::*:user/7*"
                  - "arn:aws:iam::*:user/8*"
                  - "arn:aws:iam::*:user/9*"
                  - "arn:aws:iam::*:user/+*"
                  - "arn:aws:iam::*:user/=*"
                  - "arn:aws:iam::*:user/,*"
                  - "arn:aws:iam::*:user/.*"
                  - "arn:aws:iam::*:user/_*"
                  - "arn:aws:iam::*:user/-*"

  # Lambda IAM Role
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: LambdaOrganizationsRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: LambdaAttachPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - organizations:AttachPolicy
                  - organizations:EnablePolicyType
                  - organizations:DescribeOrganization
                  - organizations:ListRoots
                  - organizations:ListPolicies
                Resource: "*"

  # Lambda Function (Python)
  AttachSCPLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: AttachSCPToOU
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          import time

          def lambda_handler(event, context):
              try:
                  organizations = boto3.client('organizations')
                  
                  # 1. Check if SCP is enabled, if not, enable it
                  ensure_scp_enabled(organizations)
                  
                  # 2. Attach SCPs to targets
                  for scp in event['ResourceProperties']['SCPAssignments']:
                      attach_policy_with_retry(organizations, scp["PolicyId"], scp["TargetId"])

                  response_data = {"Message": "All SCPs Attached Successfully"}
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {"Error": str(e)})

          def ensure_scp_enabled(organizations):
              """Ensure SCP policy type is enabled with comprehensive detection"""
              try:
                  # Get organization info and root ID first
                  org_info = organizations.describe_organization()
                  roots = organizations.list_roots()
                  root_id = roots['Roots'][0]['Id']
                  
                  print(f"Organization ID: {org_info['Organization']['Id']}")
                  print(f"Root ID: {root_id}")
                  
                  available_types = org_info['Organization']['AvailablePolicyTypes']
                  print(f"Available policy types: {available_types}")
                  
                  # More comprehensive SCP status check
                  scp_enabled = False
                  scp_exists = False
                  
                  for policy_type in available_types:
                      if policy_type['Type'] == 'SERVICE_CONTROL_POLICY':
                          scp_exists = True
                          if policy_type['Status'] == 'ENABLED':
                              scp_enabled = True
                              print(f"SCP policy type found with status: {policy_type['Status']} - ENABLED")
                          else:
                              print(f"SCP policy type found with status: {policy_type['Status']} - NOT ENABLED")
                          break
                  
                  if not scp_exists:
                      print("SCP policy type not found in available types")
                  
                  # Additional verification: Try to list policies to confirm SCP is truly enabled
                  if scp_enabled:
                      try:
                          print("Verifying SCP enablement by attempting to list policies...")
                          policies = organizations.list_policies(Filter='SERVICE_CONTROL_POLICY')
                          print(f"Successfully listed {len(policies.get('Policies', []))} SCP policies - SCP is confirmed enabled")
                          return  # SCP is truly enabled, no need to continue
                      except Exception as list_error:
                          print(f"Failed to list SCP policies despite status showing ENABLED: {str(list_error)}")
                          if "PolicyTypeNotEnabledException" in str(list_error):
                              print("SCP is not actually enabled despite status - will attempt to enable")
                              scp_enabled = False
                          else:
                              print("Unexpected error listing policies, but continuing with enablement check")
                  
                  # If we reach here, SCP needs to be enabled
                  if not scp_enabled:
                      print("SCP needs to be enabled. Attempting enablement...")
                      max_attempts = 3
                      
                      for attempt in range(max_attempts):
                          try:
                              print(f"Enablement attempt {attempt + 1}/{max_attempts}")
                              
                              # Enable SCP
                              enable_response = organizations.enable_policy_type(
                                  RootId=root_id,
                                  PolicyType='SERVICE_CONTROL_POLICY'
                              )
                              print(f"Enable response: {enable_response}")
                              
                              # Wait progressively longer
                              wait_time = 20 + (attempt * 10)  # 20s, 30s, 40s
                              print(f"Waiting {wait_time} seconds for SCP enablement to propagate...")
                              time.sleep(wait_time)
                              
                              # Verify enablement by listing policies
                              try:
                                  policies = organizations.list_policies(Filter='SERVICE_CONTROL_POLICY')
                                  print(f"✅ SCP enablement confirmed - can list {len(policies.get('Policies', []))} policies")
                                  
                                  # Double-check with describe_organization
                                  org_info_after = organizations.describe_organization()
                                  available_types_after = org_info_after['Organization']['AvailablePolicyTypes']
                                  scp_status_after = next((pt['Status'] for pt in available_types_after if pt['Type'] == 'SERVICE_CONTROL_POLICY'), 'NOT_FOUND')
                                  print(f"Organization status after enablement: {scp_status_after}")
                                  
                                  return  # Successfully enabled
                                  
                              except Exception as verify_error:
                                  print(f"Verification failed on attempt {attempt + 1}: {str(verify_error)}")
                                  if attempt == max_attempts - 1:
                                      raise Exception(f"Failed to enable SCP after {max_attempts} attempts. Last error: {str(verify_error)}")
                                  continue
                              
                          except Exception as enable_error:
                              error_msg = str(enable_error)
                              print(f"Enable attempt {attempt + 1} failed: {error_msg}")
                              
                              if "PolicyTypeAlreadyEnabledException" in error_msg:
                                  print("SCP was already enabled according to the service")
                                  # Still verify it works
                                  try:
                                      policies = organizations.list_policies(Filter='SERVICE_CONTROL_POLICY')
                                      print(f"✅ SCP confirmed working - can list {len(policies.get('Policies', []))} policies")
                                      return
                                  except Exception as verify_error:
                                      print(f"SCP shows as enabled but verification failed: {str(verify_error)}")
                                      if attempt == max_attempts - 1:
                                          raise Exception(f"SCP shows as enabled but cannot be used: {str(verify_error)}")
                                      continue
                              else:
                                  if attempt == max_attempts - 1:
                                      raise Exception(f"Failed to enable SCP after {max_attempts} attempts. Last error: {error_msg}")
                                  time.sleep(10)  # Wait before retry
                  
                  print("SCP enablement process completed")
                      
              except Exception as e:
                  print(f"Error in ensure_scp_enabled: {str(e)}")
                  raise

          def attach_policy_with_retry(organizations, policy_id, target_id, max_retries=5):
              """Attach policy with retry mechanism"""
              for attempt in range(max_retries):
                  try:
                      organizations.attach_policy(PolicyId=policy_id, TargetId=target_id)
                      print(f"Successfully attached policy {policy_id} to {target_id}")
                      return
                  except Exception as e:
                      if "PolicyTypeNotEnabledException" in str(e) and attempt < max_retries - 1:
                          print(f"Policy type not enabled on attempt {attempt + 1}, waiting longer...")
                          # Wait longer for SCP to propagate
                          wait_time = 15 + (attempt * 5)  # Progressive backoff: 15s, 20s, 25s, 30s
                          print(f"Waiting {wait_time} seconds for SCP to propagate...")
                          time.sleep(wait_time)
                          continue
                      else:
                          print(f"Error attaching policy {policy_id} to {target_id} after {attempt + 1} attempts: {str(e)}")
                          raise

  # Custom Resource 觸發 Lambda
  InvokeLambda:
    Type: Custom::InvokeLambda
    Properties:
      ServiceToken: !GetAtt AttachSCPLambda.Arn
      SCPAssignments:
        - PolicyId: !Ref DenyShield
          TargetId: !Ref RootId
        - PolicyId: !Ref DenySupport
          TargetId: !Ref FreeOU
        - PolicyId: !Ref DenyLeaveOrganization
          TargetId: !Ref FreeOU
        - PolicyId: !Ref DenyLeaveOrganization
          TargetId: !Ref BlockOU
        - PolicyId: !Ref DenyRoot
          TargetId: !Ref BlockOU
        - PolicyId: !Ref DenyCloudFront
          TargetId: !Ref BlockOU
        - PolicyId: !Ref DenyRootChange
          TargetId: !Ref NormalOU
        - PolicyId: !Ref DenySupport
          TargetId: !Ref NormalOU
        - PolicyId: !Ref DenyLeaveOrganization
          TargetId: !Ref NormalOU
        - PolicyId: !Ref DenyAccessNonPayAsGoDenyBigSizeACM
          TargetId: !Ref NormalOU

Outputs:
  FreeOUId:
    Description: "ID of the Free OU"
    Value: !Ref FreeOU
    Export:
      Name: !Sub "${AWS::StackName}-FreeOUId"

  BlockOUId:
    Description: "ID of the Block OU"
    Value: !Ref BlockOU
    Export:
      Name: !Sub "${AWS::StackName}-BlockOUId"

  NormalOUId:
    Description: "ID of the Normal OU"
    Value: !Ref NormalOU
    Export:
      Name: !Sub "${AWS::StackName}-NormalOUId"